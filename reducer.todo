Reducer Implementation Plan (Incremental, Test-Driven)
======================================================

This plan is ordered so each step can be implemented and validated independently.


Step 1 - Define reducer runtime data structures
-----------------------------------------------
Status: pending

Implement:
- `Context` with:
  - source string
  - root expr
  - builtins/global scope ids
  - diagnostics array
  - reduced output cache
- Scope and binding tables (maps keyed by ids and names)
- Helper constructors for scope/binding records

Why now:
- Later steps depend on stable state storage and caching.

Check:
- `pnpm run typecheck`


Step 2 - Index top-level scope and read `output`
------------------------------------------------
Status: pending

Implement:
- `add_expr`: store root expr and index only binding statements
- Scope-body flattening over comma/EOL
- Binding collection for `name = expr` and `name: expr`
- `reduce`: reduce only global `output`
- `display`: return reduced output string

Important details:
- Keep indexing phase non-evaluating.
- Unknown statement shape should add diagnostic and continue.

Check:
- Add a tiny smoke reducer test if needed: `output = 1` -> `1`


Step 3 - i32 literals and arithmetic with wraparound
----------------------------------------------------
Status: pending

Implement:
- int literal reduction
- binary `+`, `-`, `*`, `/` on i32 values
- signed 32-bit wrapping behavior (`|0` style semantics)

Important details:
- If either side is unresolved/non-i32, keep residual (or return Never when proven incompatible).

Check:
- reducer test: `output = 2147483647 + 1` -> `-2147483648`


Step 4 - Name resolution rules (`foo`, `.foo`, `^foo`)
------------------------------------------------------
Status: pending

Implement:
- Unprefixed parent-first lookup:
  1) parents to global+builtins
  2) current scope
  3) missing -> diagnostic + `!()`
- `.foo` current-only lookup
- `^foo` parent-only lookup

Important details:
- Reads never declare.
- Builtins are regular bindings and can be shadowed.

Check:
- critical tests for parent-first and `.a`/`^a`
- test `int = 5; output = ^int` -> `int`


Step 5 - Scope literals and selector reads
------------------------------------------
Status: pending

Implement:
- `{...}` as child scope value with fixed field set
- `foo.bar` field read
- distribution over unions for selector reads
- missing field/non-scope branch -> diagnostic + `!()` branch

Important details:
- Scope shapes are closed at construction time.

Check:
- critical union projection test: `({a=2}|{b=3}).a` -> `2`


Step 6 - Union and intersection core simplification
---------------------------------------------------
Status: pending

Implement:
- canonical `|` and `&` nodes
- simplifications:
  - `!() | A => A`
  - `!() & A => !()`
  - `() & A => A`
  - idempotence (`A | A`, `A & A`)
- basic distribution `(A | B) & C`

Important details:
- Keep deterministic ordering for stable display and tests.

Check:
- shape intersection tests:
  - `{a=int} & {a=3|2} & {a=3}` -> `{a = 3}`
  - `{a=2} & {b=3}` -> `!()`


Step 7 - Binding constraints and duplicate semantics
----------------------------------------------------
Status: pending

Implement:
- Multiple `x = ...` constraints combine via intersection
- Multiple `x: ...` constraints combine via intersection
- duplicate-binding diagnostics for repeated constraints

Important details:
- Do not stop on duplicate; continue with effective intersected value.

Check:
- `x=2; x=2; output=x` -> `2`
- `x=2; x=3; output=x` -> `!()`


Step 8 - Typed scope declarations and field writes
--------------------------------------------------
Status: pending

Implement:
- `foo: {a: int, b: int}` typed scope constraint
- allow `foo.a = v` only when:
  - `foo` is current-scope binding
  - `foo` has explicit scope type
  - target field exists in declared shape
  - field not already value-finalized (or duplicate rule applies)
- illegal writes reduce to `!()` with diagnostic

Important details:
- Writing to already concrete scope literal (closed value) is illegal.

Check:
- valid field-write test -> `{a = 3, b = 4}`
- invalid write tests -> `!()`


Step 9 - Ternary as lazy semantic expansion
-------------------------------------------
Status: pending

Implement:
- `cond ? t : f` as `(cond & t) | (!cond & f)`
- lazy branch forcing (do not eagerly reduce both branches)

Important details:
- recursion must terminate when condition resolves early.

Check:
- prepare/enable recursive Fib test shape (may still fail until instantiation exists)


Step 10 - Instantiation `T{...}` and closure parent rule
--------------------------------------------------------
Status: pending

Implement:
- treat `T{a=...}` as constrained instance
- instance scope parent is where `T` is defined (closure behavior)
- support `.field` reads within instantiation body

Important details:
- this step is required for recursive type-like definitions (Fib).

Check:
- Fib test should now execute structurally; may still need narrowing work


Step 11 - Predicate reduction and narrowing engine
--------------------------------------------------
Status: pending

Implement:
- comparisons return logical values (`()` / `!()`) when decidable
- keep unresolved predicates structurally when not decidable
- propagate constraints through intersections to a fixed point

Important details:
- must be order-independent and monotonic
- avoid infinite loops with work-queue + changed flags

Check:
- critical bidirectional test:
  `foo = {a=int, b=a==1?2:3}; output = foo & (foo.a == 1)` -> `{a = 1, b = 2}`


Step 12 - Stabilize diagnostics and display
-------------------------------------------
Status: pending

Implement:
- stable rendering for reduced and unresolved forms
- deterministic field/order output
- keep diagnostics non-fatal and inspectable

Important details:
- do not lose unresolved structure in output.

Check:
- run full test suite
- add regression tests for unresolved outputs if formatting changes


Execution Notes
---------------

- Implement in order; only move forward when the current step tests pass.
- If a later step forces display formatting changes, update reducer expectations in `test.ts` in the same commit.
- Keep diffs tight: reducer internals + directly related tests only.
