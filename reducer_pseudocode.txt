DATA STRUCTURES
    Context
        all_nodes: array of Node objects indexed by Node_Id
        nodes: Map<Node_Key, Node_Id> for interning by structure
        root_world: WORLD node holding top-level variable assignments
        root_scope: SCOPE node for top-level name resolution
        root: constraint expression node

    Node_Id
        - Integer id used to index ctx.all_nodes
        - Max id is 2^22 (MAX_ID), chosen to fit key encoding limits

    Node_Key
        - A single numeric key encoding all structural fields of a node:
          kind, lhs/rhs ids, value/ident, etc.
        - Encoding packs fields into a single JS number (f64) and relies on
          53-bit integer precision, so all fields must be small integers.
        - This is why Node_Id is capped at 2^22.

    Node kinds
        ANY: tautology
        NEVER: contradiction
        BOOL(value)
        VAR(name)
        SELECTOR(base, name)
        NEG(expr)
        AND(lhs, rhs)
        OR(lhs, rhs)
        EQ(lhs, rhs)
        SCOPE(body)
        WORLD(body, vars, parent)

    World.vars
        Map<scope_id, Map<ident, value_or_null>>
        null value means "declared but unknown"
        scope_id = 0 means "current scope" when resolving locals

    Notes
        Nodes are interned by structure. Structural equality becomes id equality.
        ctx.nodes maps Node_Key -> Node_Id, ensuring canonical ids per structure.
        AND/OR are stored in a canonicalized chain (treap) to keep a stable form.

NODE_FROM_EXPR(expr)
    if expr is true/false literal:
        return BOOL(value)

    if expr is identifier:
        return VAR(name)

    if expr is unary:
        rhs = NODE_FROM_EXPR(expr.rhs)
        if op is "+" or "-":
            // encode as a disjunction of assignments + result
            // +x becomes (x=true, true) | (x=false, false)
            // -x becomes (x=true, false) | (x=false, true)
            return OR(
                AND(EQ(rhs, TRUE),  BOOL(op == "+")),
                AND(EQ(rhs, FALSE), BOOL(op != "+"))
            )
        if op is "!":
            return NEG(rhs)

    if expr is binary:
        lhs = NODE_FROM_EXPR(expr.lhs)
        rhs = NODE_FROM_EXPR(expr.rhs)
        if op is "!=":
            // symmetric constraint
            return AND(EQ(lhs, NEG(rhs)), EQ(rhs, NEG(lhs)))
        if op is "and" or ",":
            return AND(lhs, rhs)
        if op is "or":
            return OR(lhs, rhs)
        if op is "=":
            return EQ(lhs, rhs)
        if op is "+", "-", "*", "^":
            // expand to full truth table
            return OR(
                OR(
                    AND(EQ(lhs, TRUE),  AND(EQ(rhs, TRUE),  BOOL(op(tt, tt)))),
                    AND(EQ(lhs, TRUE),  AND(EQ(rhs, FALSE), BOOL(op(tt, ff))))
                ),
                OR(
                    AND(EQ(lhs, FALSE), AND(EQ(rhs, TRUE),  BOOL(op(ff, tt)))),
                    AND(EQ(lhs, FALSE), AND(EQ(rhs, FALSE), BOOL(op(ff, ff))))
                )
            )

    if expr is selector:
        // foo.bar or foo.bar.baz
        base = NODE_FROM_EXPR(expr.lhs)
        name = expr.rhs without leading "."
        return SELECTOR(base, name)

    if expr is "{...}":
        return SCOPE(body or empty)

    if expr is "(...)":
        return body or ANY

    otherwise:
        return null

REDUCE(ctx)
    ctx.root = REDUCE_NODE(ctx.root, ctx.root_world, ctx.root_scope, outer_world = NONE)

    // fold root-world variable assignments into the root constraint
    for each ident in ctx.root_world.vars[GLOBAL_SCOPE]:
        value = assigned value or VAR(ident)
        value = REDUCE_NODE(value, ctx.root_world, ctx.root_scope, outer_world = NONE)
        ctx.root = AND(ctx.root, EQ(VAR(ident), value))

    ctx.root_scope.body = ctx.root

REDUCE_NODE(node, world, scope, outer_world, visited)
    switch node.kind
        ANY, NEVER, BOOL:
            return node

        VAR:
            if visited contains node:
                return node
            if variable not declared in (world, scope):
                declare it with null value in the correct local scope map
                return node
            if variable has a known value:
                visited.add(node)
                res = REDUCE_NODE(value, world, scope, outer_world, visited)
                visited.remove(node)
                return res
            return node

        SELECTOR:
            base = REDUCE_NODE(node.base, world, scope, outer_world, visited)
            if base is OR:
                return REDUCE_NODE(
                    OR(SELECTOR(base.lhs, name), SELECTOR(base.rhs, name)),
                    world, scope, outer_world, visited
                )
            if base is SCOPE:
                if name not declared in that scope:
                    return NEVER
                value = read variable from that scope (may be null)
                if value is null:
                    return SELECTOR(base, name)
                value = REDUCE_NODE(value, world, base, outer_world = world, visited)
                // rescope all VAR nodes inside value to be qualified by this scope
                return RESCOPE_VARS(value, base)
            if base is SELECTOR or VAR:
                return SELECTOR(base, name)
            return NEVER

        SCOPE:
            body = REDUCE_NODE(node.body, world, scope = node, outer_world = world, visited)
            if body is NEVER:
                return NEVER
            if body is OR:
                // split scope for each alternative
                return REDUCE_NODE(
                    OR(SCOPE_CLONE(body.lhs, node, world),
                       SCOPE_CLONE(body.rhs, node, world)),
                    world, scope, outer_world, visited
                )
            // reduce vars declared inside this scope and conjoin them
            for each ident in world.vars[node]:
                value = assigned value or VAR(ident)
                value = REDUCE_NODE(value, world, node, outer_world = world, visited)
                body = AND(body, EQ(VAR(ident), value))
            // clone scope with the reduced body; if id changes, remap old id -> new id
            return SCOPE_CLONE(body, node, world)

        WORLD:
            body = REDUCE_NODE(node.body, world = node, scope, outer_world, visited)
            if body is NEVER:
                return NEVER
            for each ident in node.vars[GLOBAL_SCOPE]:
                value = assigned value or VAR(ident)
                value = REDUCE_NODE(value, world = node, scope, outer_world, visited)
                if node.parent has a concrete value for ident and values differ:
                    return NEVER
                body = AND(body, EQ(VAR(ident), value))
            if node.vars is empty:
                return REDUCE_NODE(body, world, scope, outer_world, visited)
            if node is nested under OR (world != node):
                merge node.vars into world
                return REDUCE_NODE(body, world, scope, outer_world, visited)
            // rebuild world with the reduced body; if id changes, remap old id -> new id
            return WORLD(body) with updated vars and parent

        NEG:
            rhs = REDUCE_NODE(node.rhs, world, scope, outer_world, visited)
            if rhs is ANY:   return NEVER
            if rhs is NEVER: return ANY
            if rhs is BOOL:  return BOOL(!rhs.value)
            if rhs is NEG:   return rhs.rhs
            return NEG(rhs)

        EQ:
            lhs = REDUCE_NODE(node.lhs, world, scope, outer_world, visited)
            rhs = REDUCE_NODE(node.rhs, world, scope, outer_world, visited)
            if lhs is OR:
                return REDUCE_NODE(OR(EQ(rhs, lhs.lhs), EQ(rhs, lhs.rhs)),
                                   world, scope, outer_world, visited)
            if rhs is OR:
                return REDUCE_NODE(OR(EQ(lhs, rhs.lhs), EQ(lhs, rhs.rhs)),
                                   world, scope, outer_world, visited)
            if lhs == rhs:
                return ANY
            if lhs == NEG(rhs) or rhs == NEG(lhs):
                return NEVER
            if ASSIGN_IF_POSSIBLE(lhs, rhs, world, scope, outer_world):
                return ANY
            if ASSIGN_IF_POSSIBLE(rhs, lhs, world, scope, outer_world):
                return ANY
            return NEVER

        OR:
            left_world  = WORLD_FORK(world, node.lhs)
            right_world = WORLD_FORK(world, node.rhs)
            lhs = REDUCE_NODE(left_world,  left_world,  scope, outer_world, visited)
            rhs = REDUCE_NODE(right_world, right_world, scope, outer_world, visited)
            if lhs is NEVER: return WORLD_UNWRAP(world, rhs)
            if rhs is NEVER: return WORLD_UNWRAP(world, lhs)
            if lhs is ANY or rhs is ANY: return ANY
            if lhs == rhs: return WORLD_UNWRAP(world, lhs)
            if lhs == NEG(rhs) or rhs == NEG(lhs): return ANY
            return OR(lhs, rhs)

        AND:
            lhs = REDUCE_NODE(node.lhs, world, scope, outer_world, visited)
            rhs = REDUCE_NODE(node.rhs, world, scope, outer_world, visited)
            // re-run lhs to capture assignments made while reducing rhs
            lhs = REDUCE_NODE(node.lhs, world, scope, outer_world, visited)
            if lhs is NEVER or rhs is NEVER: return NEVER
            if lhs is ANY: return rhs
            if rhs is ANY: return lhs
            if lhs is OR:
                return REDUCE_NODE(OR(AND(rhs, lhs.lhs), AND(rhs, lhs.rhs)),
                                   world, scope, outer_world, visited)
            if rhs is OR:
                return REDUCE_NODE(OR(AND(lhs, rhs.lhs), AND(lhs, rhs.rhs)),
                                   world, scope, outer_world, visited)
            if lhs and rhs are BOOL with different values:
                return NEVER
            if lhs == rhs:
                return lhs
            if lhs == NEG(rhs) or rhs == NEG(lhs):
                return NEVER
            return AND(lhs, rhs)

IMPORTANT DETAILS
    - Equality is treated as a constraint solver: it assigns values to unassigned vars.
    - Two nodes are equal if their ids are equal, this is the same for all nodes, even scopes and worlds.
      This is why AND and OR chains need to be canonicalized.
    - OR branches are evaluated in forked worlds so each branch can own its own assignments.
    - Scope selectors provide qualified variable access. When a scoped value is read,
      RESCOPE_VARS rewrites unqualified VARs to SELECTOR(scope, var) so variables
      keep pointing at the original scope rather than being interpreted in the caller scope.
    - Contradictions reduce to NEVER; tautologies to ANY.
    - The reducer does a single pass; local re-reduction (notably for AND, OR expansion,
      and assignment propagation) is enough to settle constraints under current design.

HELPERS AND LOOKUPS (behavioral summary)
    WORLD_FORK(parent_world, body)
        - Creates a WORLD node around body unless it's already a WORLD
        - If new, sets its parent to parent_world

    WORLD_ADD(dst_world, src_world, scope_id, outer_world)
        - Merges src_world.vars into dst_world.vars
        - If outer_world == dst_world and a src scope is 0, remap that scope id to scope_id
        - When conflicts arise, keep existing dst values unless src provides a non-null assignment

    WORLD_UNWRAP(dst_world, src_world, scope_id, outer_world)
        - If src_world is a WORLD node and different from dst_world:
            merge its vars into dst_world, then reduce its body in dst_world
        - Otherwise return src_world as-is

    SCOPE_CLONE(body, from_scope, world_id)
        - Creates a new SCOPE node with body
        - If id changed, copies vars map from from_scope to new scope id in world.vars
        - Used when a scope body changes or when OR splits scopes

    ID RE-MAPPING AFTER SCOPE/WORLD REDUCE
        - When a reduced SCOPE/WORLD produces a new node id, the old structural key is
          re-pointed to the new id in ctx.nodes, so future lookups hit the reduced node.

    VAR LOOKUP (var_read / var_exists)
        - Walks world -> world.parent chain
        - local_scope_id starts as 0 (meaning "current scope")
        - When the walk hits outer_world, local_scope_id becomes the passed scope_id
          (this switches lookup from world-local scope 0 to the callerâ€™s scope id)
        - Reads from world.vars[local_scope_id] and returns first match
